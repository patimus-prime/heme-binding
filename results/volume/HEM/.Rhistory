# add source pdb column
result_files_df <- addpdbcol(result_files_df)
#i think each file now has its own dataframe. now we combine them
combined_results_df <- do.call("rbind", lapply(result_files_df, as.data.frame))
#@ line 981 (w/ orig PDBs, get an enormous volume. can either throw out this header, or filter as below)
# combined_results_df is now the final output of this section and the primary df
# 2. Acquire data from noise ---------------------------------------
# aight, this reply log kinda sucks so we're gonna need multiple data frames to cope
# kinda gonna reference *SA.R to deal with multiple outputs in one file
# forgive me for the extra dataframes! Will try to sweep up at the end.
# this grabs only the lines containing the grepl. We'll grab
# specific results first into respective dataframes, then join at the end.
# so, e.g. Distance df. AA# and residue code df. Angle df. Join by AA or whatever later.
# distance_raw_df contains all lines with 'Distance'
combined_results_df %>%
filter(grepl('Distance', V1)) -> distance_raw_df
# 'to a' can be used to get residue number
# aa_num_raw_df contains all lines with the residues and residue number.
combined_results_df %>%
filter(grepl('currently processing residue...', V1)) -> aa_num_raw_df
# angle_raw_df contains all lines listing residue num and angle
combined_results_df %>%
filter(grepl('Angle', V1)) -> angle_raw_df
# 'and a" can be used to get the residue number.
# PDB ID will be needed to correctly link results/avoid doubling up on the residue #s
# if necessary, add a separate column for 'unique ID' like 1-90 for ea. pdb I guess
# hopefully unnecessary!
# So, distance first:
# 3. Process Distance -------------------------------------
# angle row # == dist row #, so we're doing great so far. GJ me.
distance_raw_df %>%
separate(V1, c(NA,"Residue_Number"), "to a") -> Distance_df
Distance_df %>%
separate(Residue_Number, c('Residue_Number', 'Distance'), "is ") -> Distance_df
#volume_data_df$volume_data <- as.numeric(as.character(volume_data_df$volume_data))
Distance_df$Distance <- as.numeric(as.character(Distance_df$Distance))
Distance_df$Residue_Number <- as.numeric(as.character(Distance_df$Residue_Number))
#this separates 'em up by a delimiter, and surprisingly splits each line perfectly
#update it for less confusion. but change the name if you'd like to verify it worked
# YAAAAAAAASSSS THAT WORKED WTFFFFFFF AMAZING
# 4. Process Amino acid residues/codes -----------------------------
#aa and num: same thing as above. use '...' to get the line. Then split by ' '
# NOTE: DO NOT SPLIT BY '...' ALONE. IT FUCKS EVERYTHING UP, likely due to regular expressions
aa_num_raw_df %>%
separate(V1, c(NA,"another_step_req"), "processing residue...") -> aa_num_raw_df
aa_num_raw_df %>%
separate(another_step_req, c('Residue_Code','Residue_Number'),' ') -> aa_num_raw_df
# next two lines to get JUST the number in the second column.
regexp <- "[[:digit:]]+"
str_extract(aa_num_raw_df$Residue_Number,regexp) -> aa_num_raw_df$Residue_Number
aa_num_raw_df -> ResCode_ResNum_df
ResCode_ResNum_df$Residue_Number <- as.numeric(as.character(ResCode_ResNum_df$Residue_Number))
# 5. PRocess angles ------------------------------------
# linking by PDB ID and residue NUM now possible! would give + Residue Code, in this case
# FINALLY! We get angle!
# delimiter ' and ' to get the: aNN and angle.
angle_raw_df %>%
separate(V1, c(NA,'raw_angle_lines'), 'and ') -> angle_raw_df
#split by ' is '
angle_raw_df %>%
separate(raw_angle_lines, c('Residue_Number','Angle'),' is ') -> Angles_df
str_extract(Angles_df$Residue_Number,regexp) -> Angles_df$Residue_Number
Angles_df$Residue_Number <- as.numeric(as.character(Angles_df$Residue_Number))
# so for our purposes now, we have: Angles_df. ResCode_ResNum_df. Distance_df
#this must all now be merged!
#use this:
# https://stackoverflow.com/questions/6709151/how-do-i-combine-two-data-frames-based-on-two-columns
# NOTE: ALL THE ABOVE 'AS.NUMERIC, AS.CHARACTER' ARE TO GET THE DISTANCE FROM STR -> NUMERIC,
# SO THAT THE MERGE BELOW CAN ACTUALLY OCCUR.
# 6. Merge ---------------------------
omega_df <- merge(Distance_df,Angles_df,by = c("PDB_ID","Residue_Number"))#,"Residue_Number"))
omega_df <- merge(omega_df,ResCode_ResNum_df, by = c("PDB_ID","Residue_Number"))
Distance_and_Angles_df <- omega_df
# 7. Plotting ---------------------------
# all data in Distances...df, and we are only interested in the angles.
# btw we can probably revert to'plane' for HEM. Since only interested in angles
# we must convert type to factor, for this plot
Distance_and_Angles_df$Angle <- as.numeric(as.character(Distance_and_Angles_df$Angle))
Distance_and_Angles_df$Residue_Number <- as.numeric(as.character(Distance_and_Angles_df$Residue_Number))
Distance_and_Angles_df$Residue_Code <- as.factor(Distance_and_Angles_df$Residue_Code)
#head(Distance_and_Angles_df)
angleplot <- ggplot(Distance_and_Angles_df, aes(x=Residue_Code, y=Angle, fill = Residue_Code)) +
geom_violin(trim=FALSE) +
labs(title = "Angles of Residues v. Heme (planar) in each PDB", x="Residue",y="Angle")
angleplot #ENSURE YOU CONVERT TO NUMERIC DATA TYPES ABOVE
#welp, that's not conclusive, at all.
# CLEANUP ---------------------------
rm(awesome_df,
combined_results_df,
dist_aa_df,
distance_raw_df,
omega_df,
result_files_df,
regexp,
result_files_ls,
aa_num_raw_df,
aa_super_df,
ang1_df,
angle_raw_df
)
#return stuff ----------
return(#list()
)
}
library(dplyr)
library(data.table)
library(tidyr)
library(ggplot2) #thus far not used 22 June 2021
source("~/heme-binding/scripts/r/addpdbcol.R")
#for filtering: https://www.youtube.com/watch?v=PsSqn0pxouM
ligandSA_fn <- function(activeLigand,activeResultPath)
{
paste(activeLigand,"ligand SA processing...")
setwd(activeResultPath)
# 0. Notes on global variables...---------------------------
#may need to specify this option every run/change for running ALL PROCESSED FILES
#options(max.print = 999999999999999999999) #or whatever number
# 1. Assembling all results into one dataframe -----------------------------
#set working directory to the folder w files!
#hemeSA_path = "~/heme-binding/results/hemeSA"
#setwd(hemeSA_path)
#setwd("~/heme-binding/results/hemeSA")
# import all the shit that's been processed
# currently using results specific file, all of type .txt; therefore:
result_files_ls <- list.files(pattern = "*.ligandSA.txt") #double check what's up
# may need to add path = whatever from wd into the parentheses
# result_files_ls is now a list of all the fuckin txt files
# now read them from the list into a dataframe
result_files_df <- lapply(result_files_ls, function(x) {read.delim(file = x, header = FALSE)})
# add source pdb column
result_files_df <- addpdbcol(result_files_df)
#i think each file now has its own dataframe. now we combine them
combined_results_df <- do.call("rbind", lapply(result_files_df, as.data.frame))
#@ line 981 (w/ orig PDBs, get an enormous volume. can either throw out this header, or filter as below)
# combined_results_df is now the final output of this section and the primary df
# 2. Acquire data from noise ------------
# only lines with 'surface area'
combined_results_df %>%
filter(grepl('surface area = ', V1)) -> combined_results_df
# we must divide this into two separate data frames, excluded and accessible.
# they can be merged later into two columns in the same dataframe.
# FIXME: Perhaps rewrite this later when you feel more confident in R skills
combined_results_df %>%
filter(grepl('excluded', V1)) -> excluded_df
combined_results_df %>%
filter(grepl('accessible', V1)) -> accessible_df
#these two df would change into two columns of the same in the case of rewrite
# acquire only the numeric data
# THIS ONE TO CHECK, BUT SEEMS 100% OK!
#excluded_df %>%
#  separate(V1, c(NA ,"exc_sa"), "= ") -> excluded_df[['exc_sa']]
excluded_df %>%
separate(V1, c(NA ,paste(activeLigand,"_Excluded_SA",sep = "")), "= ") -> excluded_df
accessible_df %>%
separate(V1, c(NA,paste(activeLigand,"_Accessible_SA",sep = "")),"= ") -> accessible_df#[['perf']]
excluded_df %>%
separate(V1, c(NA ,paste(activeLigand,"_Excluded_SA",sep = "")), "= ") -> excluded_df
accessible_df %>%
separate(V1, c(NA,paste(activeLigand,"_Accessible_SA",sep = "")),"= ") -> accessible_df#[['perf']]
source("~/heme-binding/scripts/r/ligandSA.R")
resultPath = "~/heme-binding/results/ligandSA/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
ligandSA_df <- aaFreq_fn(activeLigand,activeResultPath)
assign(paste(activeLigand,"_aaFreqDf",sep=""), aa_freq_df)
}
ligandSA_fn <- function(activeLigand,activeResultPath)
{
paste(activeLigand,"ligand SA processing...")
setwd(activeResultPath)
# 0. Notes on global variables...---------------------------
#may need to specify this option every run/change for running ALL PROCESSED FILES
#options(max.print = 999999999999999999999) #or whatever number
# 1. Assembling all results into one dataframe -----------------------------
#set working directory to the folder w files!
#hemeSA_path = "~/heme-binding/results/hemeSA"
#setwd(hemeSA_path)
#setwd("~/heme-binding/results/hemeSA")
# import all the shit that's been processed
# currently using results specific file, all of type .txt; therefore:
result_files_ls <- list.files(pattern = "*.ligandSA.txt") #double check what's up
# may need to add path = whatever from wd into the parentheses
# result_files_ls is now a list of all the fuckin txt files
# now read them from the list into a dataframe
result_files_df <- lapply(result_files_ls, function(x) {read.delim(file = x, header = FALSE)})
# add source pdb column
result_files_df <- addpdbcol(result_files_df)
#i think each file now has its own dataframe. now we combine them
combined_results_df <- do.call("rbind", lapply(result_files_df, as.data.frame))
#@ line 981 (w/ orig PDBs, get an enormous volume. can either throw out this header, or filter as below)
# combined_results_df is now the final output of this section and the primary df
# 2. Acquire data from noise ------------
# only lines with 'surface area'
combined_results_df %>%
filter(grepl('surface area = ', V1)) -> combined_results_df
# we must divide this into two separate data frames, excluded and accessible.
# they can be merged later into two columns in the same dataframe.
# FIXME: Perhaps rewrite this later when you feel more confident in R skills
combined_results_df %>%
filter(grepl('excluded', V1)) -> excluded_df
combined_results_df %>%
filter(grepl('accessible', V1)) -> accessible_df
#these two df would change into two columns of the same in the case of rewrite
# acquire only the numeric data
# THIS ONE TO CHECK, BUT SEEMS 100% OK!
#excluded_df %>%
#  separate(V1, c(NA ,"exc_sa"), "= ") -> excluded_df[['exc_sa']]
excluded_df %>%
separate(V1, c(NA ,paste(activeLigand,"_Excluded_SA",sep = "")), "= ") -> excluded_df
accessible_df %>%
separate(V1, c(NA,paste(activeLigand,"_Accessible_SA",sep = "")),"= ") -> accessible_df#[['perf']]
# only max, in case of duplicate heme
excluded_df %>%
group_by(PDB_ID) %>% slice(which.max(Heme_Excluded_SA)) -> max_excluded_df
accessible_df %>%
group_by(PDB_ID) %>% slice(which.max(Heme_Accessible_SA)) -> max_accessible_df
# 4 into one dataframe --------------------
hemeSA_df <- max_excluded_df
hemeSA_df['Heme_Accessible_SA'] <- max_accessible_df$Heme_Accessible_SA
# and convert into numerics lol!!!!
hemeSA_df$Heme_Excluded_SA <- as.numeric(as.character(hemeSA_df$Heme_Excluded_SA))
hemeSA_df$Heme_Accessible_SA <- as.numeric(as.character(hemeSA_df$Heme_Accessible_SA))
# put into one dataframe
#hemeSA_df <- excluded_df
#hemeSA_df['Heme_Accessible_SA'] <- accessible_df$Heme_Accessible_SA
#BING BANG BOOM! hemeSA_df is the final result of all this painful work lol
#colnames(hemeSA_df)[which(names(hemeSA_df) == "V1")] <- "Excluded_SA"
#colnames(dataframe)[which(names(dataframe) == "columnName")] <- "newColumnName"
#https://stackoverflow.com/questions/6081439/changing-column-names-of-a-data-frame
}
ligandSA_fn <- function(activeLigand,activeResultPath)
{
paste(activeLigand,"ligand SA processing...")
setwd(activeResultPath)
# 0. Notes on global variables...---------------------------
#may need to specify this option every run/change for running ALL PROCESSED FILES
#options(max.print = 999999999999999999999) #or whatever number
# 1. Assembling all results into one dataframe -----------------------------
#set working directory to the folder w files!
#hemeSA_path = "~/heme-binding/results/hemeSA"
#setwd(hemeSA_path)
#setwd("~/heme-binding/results/hemeSA")
# import all the shit that's been processed
# currently using results specific file, all of type .txt; therefore:
result_files_ls <- list.files(pattern = "*.ligandSA.txt") #double check what's up
# may need to add path = whatever from wd into the parentheses
# result_files_ls is now a list of all the fuckin txt files
# now read them from the list into a dataframe
result_files_df <- lapply(result_files_ls, function(x) {read.delim(file = x, header = FALSE)})
# add source pdb column
result_files_df <- addpdbcol(result_files_df)
#i think each file now has its own dataframe. now we combine them
combined_results_df <- do.call("rbind", lapply(result_files_df, as.data.frame))
#@ line 981 (w/ orig PDBs, get an enormous volume. can either throw out this header, or filter as below)
# combined_results_df is now the final output of this section and the primary df
# 2. Acquire data from noise ------------
# only lines with 'surface area'
combined_results_df %>%
filter(grepl('surface area = ', V1)) -> combined_results_df
# we must divide this into two separate data frames, excluded and accessible.
# they can be merged later into two columns in the same dataframe.
# FIXME: Perhaps rewrite this later when you feel more confident in R skills
combined_results_df %>%
filter(grepl('excluded', V1)) -> excluded_df
combined_results_df %>%
filter(grepl('accessible', V1)) -> accessible_df
#these two df would change into two columns of the same in the case of rewrite
# acquire only the numeric data
# THIS ONE TO CHECK, BUT SEEMS 100% OK!
#excluded_df %>%
#  separate(V1, c(NA ,"exc_sa"), "= ") -> excluded_df[['exc_sa']]
excluded_df %>%
separate(V1, c(NA ,paste(activeLigand,"_Excluded_SA",sep = "")), "= ") -> excluded_df
excluded_df %>%
group_by(PDB_ID) %>% slice(which.max(Heme_Excluded_SA)) -> max_excluded_df
accessible_df %>%
group_by(PDB_ID) %>% slice(which.max(Heme_Accessible_SA)) -> max_accessible_df
#ligandSA_fn <- function(activeLigand,activeResultPath)
#{
activeLigand = "HEM"
activeLigand
#ligandSA_fn <- function(activeLigand,activeResultPath)
#{
activeLigand = "HEM"
activeLigand
print(activeLigand)
activeLigand
activeLignd
activeResultPath = "~/heme-binding/results/ligandSA/"
activeResultPath = "~/heme-binding/results/ligandSA/HEM"
setwd(activeResultPath)
paste(activeLigand,"ligand SA processing...")
activeLigand
#ligandSA_fn <- function(activeLigand,activeResultPath)
#{
activeLigand = "HEM"
#ligandSA_fn <- function(activeLigand,activeResultPath)
#{
activeLigand = c("HEM")
activeLigand
# Ligand surface area ----------------------
source("~/heme-binding/scripts/r/ligandSA.R")
resultPath = "~/heme-binding/results/ligandSA/"
# AA Frequency -----------------
source("~/heme-binding/scripts/r/aa_frequency.R")
resultPath = "~/heme-binding/results/aa_frequency/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
aa_freq_df <- aaFreq_fn(activeLigand,activeResultPath)
assign(paste(activeLigand,"_aaFreqDf",sep=""), aa_freq_df)
}
# This is the main R file for this project. Launches other scripts used
library(dplyr)
library(data.table)
library(tidyr)
library(ggplot2) #thus far not used 22 June 2021
library(stringr)
source("~/heme-binding/scripts/r/addpdbcol.R")
#source("C:/Users/nobody/Documents/R/MyScript.R")
# for the pdb-Titles_codes script, YOU MUST NOT HAVE ANYTHING THAT COULD INTERFERE
# WITH THE REGEXP '.pdb' in the folder!!!! this will throw errors!
# now still throws an error but minor. I think it doesn't like the source dataframe only having 1 column
#source("~/heme-binding/scripts/r/metal_coordination.R") #garbage
# ok let's reorder
# DECLARATIONS --------------
ligandList = list("HEM")
angstromDistance = 7.0 #not sure if used here, maybe useful for figures!
# need a different loop for each script, as the result paths are different for all
#------ VOLUME ---------
source("~/heme-binding/scripts/r/volume.R")
resultPath = "~/heme-binding/results/volume/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
volume_dfs <- volumeFn(activeLigand,activeResultPath)
#this line is freaky fresh
# paste() automates df name creation, second arg is the df assigned. BAM!
assign(paste(activeLigand,"_maxVolDf",sep=""), volume_dfs$maxVolDf)
}
# FUCK YES THAT'S VOLUME AUTOMATED BABY! Merging will be funky, require another loop
# loop for ea. ligand to create unique mega DFs. Similar process as this.
# bam! that's all the thinking required. the rest is typing and changing
# to accomodate for HEM v. activeLigand. Bing bang boom!
# after that, adding data, testing, and otherwise doneeeeeee omg lol
# finish tonight omg fuck yess brooooo! call peeps even jesus awesomeeeee
# AA Frequency -----------------
source("~/heme-binding/scripts/r/aa_frequency.R")
resultPath = "~/heme-binding/results/aa_frequency/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
aa_freq_df <- aaFreq_fn(activeLigand,activeResultPath)
assign(paste(activeLigand,"_aaFreqDf",sep=""), aa_freq_df)
}
# Ligand surface area ----------------------
source("~/heme-binding/scripts/r/ligandSA.R")
resultPath = "~/heme-binding/results/ligandSA/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
ligandSA_df <- ligandSA_fn(activeLigand,activeResultPath)
assign(paste(activeLigand,"_ligandSA_df",sep = ""), ligandSA_df)
}
# Pocket Surface Area ------------------------
source("~/heme-binding/scripts/r/pocketSA.R")
resultPath = "~/heme-binding/results/pocketSA/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
pocketSA_df <- pocketSA_fn(activeLigand,activeResultPath)
assign(paste(activeLigand,"_pocketSA_df",sep = ""), pocketSA_df)
}
# AA to ligand plane -------------
source("~/heme-binding/scripts/r/dist_angles.R")
resultPath = "~/heme-binding/results/distances_and_angles/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
planar_angles_list <- aaAnglesFn(activeLigand,activeResultPath)
assign(paste(activeLigand,"_planar_angles_list",sep = ""), planar_angles_list)
}
HEM_planar_angles_list$angleDF #DANK
# Distances of AA atoms to Fe ------------------
source("~/heme-binding/scripts/r/only_distances.R")
resultPath = "~/heme-binding/results/only_distances/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
distancesList <- distancesFn(activeLigand,activeResultPath)
assign(paste(activeLigand,"_distances_list",sep=""),distancesList)
#planar_angles_list <- aaAnglesFn(activeLigand,activeResultPath)
#assign(paste(activeLigand,"_planar_angles_list",sep = ""), planar_angles_list)
}
distancesList$dataframe #NOTE: DO NOT FORGET TO NAME STUFF LMAO
#  Angles CACBFe -------------------------------
source("~/heme-binding/scripts/r/anglesCACBFE.R")
resultPath = "~/heme-binding/results/angles_CA_CB_Fe/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
CACBFE_df <- CACBFE_fn(activeLigand,activeResultPath)
assign(paste(activeLigand,"_CACBFe_DF",sep = ""),CACBFE_df)
# distancesList <- distancesFn(activeLigand,activeResultPath)
#assign(paste(activeLigand,"_distances_list",sep=""),distancesList)
#planar_angles_list <- aaAnglesFn(activeLigand,activeResultPath)
#assign(paste(activeLigand,"_planar_angles_list",sep = ""), planar_angles_list)
}
#CACBFE_df
#FIXME! ERROR FROM HERE R STOPPED GIVING CORRECT FEEDBACK
# yeahp, just restart the computer fuuuuuuck R
# PDBs titles codes ---------------
# bullshit ones, put below I guess Idk
source("~/heme-binding/scripts/r/pdb_titles_codes.R") #error here investigate 15 July 2021
resultPath = "~/heme-binding/pdb_source_data/0_raw_download/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
pdbCodeDf <- pdbTitlesCodesFn(activeLigand,activeResultPath)
assign(paste(activeLigand,"_pdbCodesDf",sep=""),pdbCodeDf)
}
# PDB source organism ---------------------
source("~/heme-binding/scripts/r/source_organism.R")
resultPath = "~/heme-binding/pdb_source_data/0_raw_download/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
sourceOrganismDf <- sourceOrganismFn(activeLigand,activeResultPath)
assign(paste(activeLigand,"_sourceOrganismDf",sep=""),sourceOrganismDf)
#   pdbCodeDf <- pdbTitlesCodesFn(activeLigand,activeResultPath)
#  assign(paste(activeLigand,"_pdbCodesDf",sep=""),pdbCodeDf)
}
eval(parse(text="sourceOrganismDf"))
zDF <- merge(HEM_pdbCodesDf,HEM_sourceOrganismDf,by.x = "PDB_ID")
View(zDF)
yDF <- merge(eval(parse(text = paste(activeLigand,"_pdbCodesDf",sep = ""))),
eval(parse(text = paste(activeLigand,"_sourceOrganismDf",sep = ""))),
by.x = "PDB_ID")
View(yDF)
eval(parse(text = paste(activeLigand,"_dfList",sep = ""))) <- list(volume_dfs$maxVolDf)
eval(parse(text = paste(activeLigand,"_dfList",sep = ""))) <- list(volume_dfs$maxVolDf,
volume_dfs$allVolDf)
xx <- list(volume_dfs$maxVolDf)
eval(parse(text = paste(activeLigand,"_dfList",sep = ""))) <- list(xx)
eval(parse(text = paste(activeLigand,"_dfList",sep = ""))) = list(volume_dfs$maxVolDf,
volume_dfs$allVolDf)
#eval(parse(text = paste(activeLigand,"_dfList",sep = ""))) = list(volume_dfs$maxVolDf,
#                                                                  volume_dfs$allVolDf)
xx <- list(volume_dfs$maxVolDf)
eval(parse(text = paste(activeLigand,"_dfList",sep = ""))) <- list(xx)
source('~/heme-binding/scripts/r/main.R', echo=TRUE)
eval(parse(text = paste(activeLigand,"_dfList",sep = ""))) = xx
eval(parse(text = paste(activeLigand,"_dfList",sep = ""))) <- xx
"y" = list(volume_dfs$allVolDf)
"yy" = list(volume_dfs$allVolDf)
View(yy)
paste(activeLigand,"_dfList",sep = "") = list(volume_dfs$maxVolDf,
volume_dfs$allVolDf)
paste(activeLigand,"_dfList",sep = "") <- list(volume_dfs$maxVolDf,
volume_dfs$allVolDf)
# This is the main R file for this project. Launches other scripts used
library(dplyr)
library(data.table)
library(tidyr)
library(ggplot2) #thus far not used 22 June 2021
library(stringr)
source("~/heme-binding/scripts/r/addpdbcol.R")
#source("C:/Users/nobody/Documents/R/MyScript.R")
# for the pdb-Titles_codes script, YOU MUST NOT HAVE ANYTHING THAT COULD INTERFERE
# WITH THE REGEXP '.pdb' in the folder!!!! this will throw errors!
# now still throws an error but minor. I think it doesn't like the source dataframe only having 1 column
#source("~/heme-binding/scripts/r/metal_coordination.R") #garbage
# ok let's reorder
# DECLARATIONS --------------
ligandList = list("HEM")
angstromDistance = 7.0 #not sure if used here, maybe useful for figures!
# Initialize list of DFs/lists, add results in each for loop
# FIXME! The automated naming doesn't like this lol
# need a different loop for each script, as the result paths are different for all
#------ VOLUME ---------
source("~/heme-binding/scripts/r/volume.R")
resultPath = "~/heme-binding/results/volume/"
for(ligand in 1:(length(ligandList)))
{
activeLigand = ligandList[[ligand]]
activeResultPath = paste(resultPath,activeLigand,sep = "")
volume_dfs <- volumeFn(activeLigand,activeResultPath)
#this line is freaky fresh
# paste() automates df name creation, second arg is the df assigned. BAM!
assign(paste(activeLigand,"_maxVolDf",sep=""), volume_dfs$maxVolDf)
paste(activeLigand,"_dfList",sep = "") = list(volume_dfs$maxVolDf,
volume_dfs$allVolDf)
paste(activeLigand,"_dfList",sep = "") = list(volume_dfs$maxVolDf,
volume_dfs$allVolDf)
eval(parse(text=paste(activeLigand,"_dfList",sep = ""))) = list(volume_dfs$maxVolDf,
volume_dfs$allVolDf)
all(zDF == yDF)
all(zDF == yDF)
all_equal(zDF,yDF)
identical(zDF,yDF)
